#  数据库的3F 原则

3F 是数据库设计和关系模式规范化中的核心原则：

| **F**                                    | **含义**        | **解释**                 |
| ---------------------------------------- | ------------- | ---------------------- |
| **无冗余（Freedom from redundancy）**         | 数据不重复         | 避免重复存储，减少存储空间浪费        |
| **无更新异常（Freedom from update anomalies）** | 更新、删除、插入不产生异常 | 例如修改一条数据，不会造成其他相关数据不一致 |
| **无损连接（Freedom from lossless join）**     | 分解后可以通过连接还原原表 | 分解子表能完整还原原表数据，不丢信息     |

**2NF**：消除部分依赖，不涉及多值依赖
**3NF**：消除传递依赖，不涉及多值依赖
**4NF**：要求在满足 BCNF 的前提下进一步消除多值依赖
**BCNF**：主要解决的是候选键与决定因素关系

> 总结一句话：**3F = 无冗余 + 无异常 + 无损连接**

---

# **无损连接 vs 有损连接**

- **无损连接（Lossless Join）**
    > 分解后的子表通过自然连接能完整还原原表，不会产生“假数据”或丢数据。
    

**判断条件（两个子表）**：

$$
R_1 \cap R_2 \to R_1 \quad \text{或} \quad R_1 \cap R_2 \to R_2
$$

- 交集属性能唯一确定某个子表的所有属性 → 无损连接
- 例：R1={A,B}, R2={A,C}, F={A→B, B→C} → 交集 {A} → R1 的属性 A,B 可确定 → 无损

- **有损连接（Lossy Join）**
	分解后的子表连接回原表会产生多余组合或丢失数据


- - 例：R1={A}, R2={B,C}, 没有交集 → 有损 ❌

---

# **保持函数依赖 vs 不保持函数依赖**

- **保持函数依赖（Dependency Preservation）**
    
    > 分解后，每条原始函数依赖都至少能在一个子表独立验证
    - 例：R(A,B,C), F={A→B, B→C}, 分解 R1={A,B}, R2={B,C}
        - A→B 在 R1
        - B→C 在 R2
        - ✅ 保持函数依赖

- **不保持函数依赖**
    > 分解后，有些原始函数依赖不能在任何单独子表验证
    - 例：R(A,B,C), F={A→B, B→C}, 分解 R1={A,B}, R2={A,C}
        - B→C 无法在 R1 或 R2 单独验证
        - ❌ 不保持函数依赖

---
# **Armstrong 公理系统中的函数依赖推理规则**

- **若 A→B，B→C，则 A→C**：这是**传递律**，是 Armstrong 公理系统的基本推理规则之一，但不是合并规则。
- **Y⊆X⊆U，则 X→Y**：这是**自反律**，表示一个属性集对其自身的子集有函数依赖。
- **A→B，A→C，则 A→BC**：**正确**，这是**合并规则**，表示如果 A 能确定 B，且 A 能确定 C，那么 A 就能确定 BC。该规则可由自反律、增广律和传递律组合推出。
- **A→B，C⊆B，则 A→C**：这是**分解规则**的逆形式（通常我们说 X→YZ 推出 X→Y 和 X→Z），但这种“反向包含式”的表述不严谨，且不是合并规则。

---
# **分布式数据库系统的四种透明性**

- **分片透明**：用户不必关心数据是如何分片的，所有操作在全局关系层面完成，错误。  
- **复制透明**：用户不必关心数据在各节点的复制情况，系统自动维护复制数据的一致性，错误。  
- **位置透明**：用户不必知道所操作数据的存储位置，数据迁移不影响应用程序，错误。  
- **逻辑透明**：又称局部映像透明，指用户无需了解局部数据库使用的数据模型或操纵语言，系统负责数据模型和语言的转换。
---
# **数据库转储方式的分类与应用场景**

数据库转储是将数据库中全部或部分数据复制到外部存储介质中，以便在发生故障时进行恢复。转储方式主要按**操作期间是否允许事务运行**和**转储范围**来分类。

- **静态全局转储**：全局转储是转储数据库全部数据，静态方式要求转储期间禁止任何事务访问数据库  
- **动态全局转储**：全局转储数据库全部数据，动态方式允许在转储期间继续进行事务处理，实现转储与事务并发执行。  
- **静态增量转储**：增量转储只转储自上次转储以来发生变化的数据，且静态方式要求停止事务处理 
- **动态增量转储**：增量转储且允许事务并发，但题干要求转储全部数据，而非部分变化数据。

---
# **分布式数据库中的二阶段提交协议（Two-Phase Commit, 2PC）**

**二阶段提交的核心目标**：在多个分布式节点参与同一事务时，保证事务的**原子性**与**一致性**。
- **角色**：
    - 协调者（Coordinator）：负责组织事务的提交或回滚。
    - 参与者（Participants）：实际执行事务操作的数据库节点。
    
**两个阶段**：
1. **表决阶段（准备阶段，Voting/Prepare Phase）**
    - 协调者向所有参与者发送“准备提交事务”的请求。
    - 参与者本地执行事务并记录 redo/undo 日志，但不提交。
    - 各参与者返回“同意提交”或“中止”的表决结果给协调者。
2. **执行阶段（提交阶段，Commit Phase）**
    - 如果协调者收到了所有参与者的“同意提交”，则向所有参与者发送“提交”命令，参与者正式提交并释放锁资源。
    - 如果有任何一个参与者投“中止”，则协调者向所有参与者发送“回滚”命令，参与者执行回滚并释放锁资源。
    
---
# **数据仓库的四大特点**

- **面向主题**：指数据仓库按照特定分析主题（如客户、产品、销售）组织数据，而不是按业务过程组织。  
- **集成性**：指数据仓库中的数据来源于不同业务系统，需要进行统一编码、格式、单位等转换，消除不一致性。  
- **相对稳定性**：又称非易失性，数据进入数据仓库后主要用于查询分析，很少修改或删除，仅在定期加载时更新。  
- **反映历史变化**：指数据仓库保存了从过去到现在不同时间点的数据快照，用于分析趋势与变化

# **关系数据库的安全机制与封装手段**

数据库为了保证内部结构（如表结构、字段设计、主外键约束等）不暴露给外部用户，通常会通过封装方式向外提供操作接口。以下逐项分析各选项的作用和限制：

- **索引**：索引主要用于**加速查询操作**，并不涉及对数据的更新，也无法提供安全机制来封装数据库结构
- **视图**：视图是一种虚拟表，确实可以隐藏数据库的部分结构信息，具有一定的安全作用，但**并不是专门为数据更新而设计**，且大多数视图不能直接更新数据（特别是多表联合视图、聚合视图等）。所以不符合题干中“进行数据更新”的描述
- **存储过程** 存储过程可以将对数据的增删改查操作封装成一个可执行的过程，供外部程序调用，**既能进行数据更新，又能有效隐藏数据库表结构和业务逻辑**，从而提升安全性，是典型的数据库访问封装机制
- **触发器**：触发器是系统对数据变化的被动响应机制，适用于自动完成某些约束检查或日志记录，**不能作为第三方调用的数据更新接口**

# **分布式数据库系统的模式结构**

- **分片模式**：用于描述如何将全局数据逻辑地划分为若干片段，但不描述整体逻辑结构
- **全局外模式**：位于全局概念模式之上，针对不同应用提供不同的视图，类似于传统数据库中的外模式，不能描述整个系统的逻辑结构
- **分布模式**：在标准定义中并不是一个正式的模式层次，指的是数据的分布方式
- **全局概念模式**：是描述整个分布式数据库中所有数据的**逻辑结构**的模式层次，使用户感知不到数据的物理分布

---

# NDB
NDB 是一种通过网络（如 4G/5G）访问远程数据库的架构，客户端负责与嵌入式程序对接，通信协议负责定义与远程服务器交互的规则，服务器端维护实际的数据库数据

- NDB 架构由客户端、通信协议和远程服务器组成
- 客户端提供访问接口，通信协议用于交互规范，远程服务器进行数据管理，这正是 NDB 的工作分工
- NDB 的客户端模块轻量化、可裁剪、代码可复用，符合其在嵌入式环境的设计要求
- 该描述是**基于文件的数据库系统**的特点，而非 NDB。NDB 数据存储在远程服务器的数据库中，客户端不直接操作数据文件

# **数据库三级模式结构中的各个模式含义及其应用**

数据库的三级模式包括**外模式、模式和内模式**，是数据库系统体系结构的核心内容。

- **外模式**：也称为子模式或用户模式，是用户看到并使用的数据库视图，是数据库与用户之间的接口。外模式定义了用户能看到和操作的数据子集，不涉及数据的存储方式
- **模式**：是数据库的逻辑结构，是数据库中所有数据的逻辑视图和整体结构的描述，包括各个数据项之间的逻辑关系。虽然涉及表结构，但并不涉及聚簇索引这种物理存储结构
- **内模式**：描述的是数据在物理层的存储方式，包括文件的组织方式、索引结构（如聚簇索引和非聚簇索引）、数据的压缩方式等。聚簇索引属于数据的物理组织结构，因此修改聚簇索引改变的是数据库的内模式。
- **概念模式（Conceptual Schema）**：也叫模式（Schema），是对**整个数据库中数据的逻辑结构和特征**的描述，所有用户的公共视图，面向数据库管理员
- **逻辑模式**常常是概念模式的另一种称法，也描述的是**全局逻辑结构**


- **用户模式**：不是数据库三级模式结构中的术语，属于干扰项

---

# **数据库设计流程中各阶段的具体任务**

数据库设计通常分为四个主要阶段：

- **需求分析阶段**：了解用户业务需求，获取数据需求，不涉及数据结构的设计。
- **概念设计阶段**：使用E-R模型等抽象工具构建概念模型，描述数据实体及其联系。
- **逻辑设计阶段**：将概念模型（如E-R图）转换为具体的逻辑模型（如关系模式），并进行**关系模式的规范化与反规范化**，以满足性能与实际应用需求。
- **物理设计阶段**：确定存储结构、索引设计等物理实现细节，提升数据操作效率。


# **完整性约束**

- **实体完整性**：实体完整性是指数据库中的每个实体（即表的每一行）必须是唯一的，通常涉及主键的设置，确保每条记录的唯一性
- **参照完整性**：参照完整性是指一个表中的外键值必须对应另一个表的主键值。它用于保持表与表之间的数据一致性。这个选项不适用于描述**性别列**的固定取值
- **用户定义完整性**：用户定义完整性是指数据库中可以由用户根据实际业务需求定义的特定规则或约束。在这里，性别列只允许取"男"或"女"的值，这正是用户自定义的约束规则

---
# **关系数据库中关系代数操作的基本概念**

关系数据库使用集合论中的概念，关系可以看作是元组的集合。关系代数提供了一系列操作，这些操作以关系作为输入，并产生一个新的关系作为输出。

- **记录**：记录是关系中的单行数据，等价于元组。虽然它是关系的一部分，但关系代数操作并不是以单条记录为单位进行运算的
- **元组**：元组是关系中的一行数据，即记录，但关系代数操作是以“关系”作为整体输入和输出的，操作不是以单个元组为单位
- **集合**：关系在数学上定义为元组的集合。关系代数中的各种操作，例如选择、投影、连接、并、交、差等，都是以关系（集合）为操作对象，并输出新的关系（集合）
- **列**：列是关系的属性，虽然投影操作涉及列，但投影操作的结果仍是一个新的关系，即元组的集合，不是单独的列